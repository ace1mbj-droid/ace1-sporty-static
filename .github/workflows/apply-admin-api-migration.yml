name: Apply admin_api_url migration

on:
  workflow_dispatch: {}
  push:
    branches: [ main ]

jobs:
  apply-migration:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install psql
        run: sudo apt-get update && sudo apt-get install -y postgresql-client

      - name: Apply migration SQL (safe parse)
        env:
          SUPABASE_DB_URL: ${{ secrets.SUPABASE_DB_URL }}
        run: |
          if [ -z "$SUPABASE_DB_URL" ]; then
            echo 'Missing SUPABASE_DB_URL secret; cannot apply migration.'
            exit 1
          fi

          echo "Debug: psql version"
          psql --version || true
          echo "Debug: python version"
          python --version || true
          
            # Print sanitized parsed host/port/db/user (no secrets). Use a robust parser that handles
            # IPv6 bracketed hosts and passwords containing '@'. Don't raise on parse errors.
          python - <<'PY'
            import os
            u = os.getenv('SUPABASE_DB_URL') or ''
            if not u:
              print('DBG: SUPABASE_DB_URL missing')
            else:
              try:
                rest = u.split('://', 1)[1] if '://' in u else u
                netloc = rest.split('/', 1)[0]
                db = rest.split('/', 1)[1] if '/' in rest else ''
                if '@' in netloc:
                  creds, hostport = netloc.rsplit('@', 1)
                  user = creds.split(':', 1)[0] if creds else ''
                else:
                  hostport = netloc
                  user = ''

                # handle IPv6 bracketed '[::1]:5432'
                host = hostport
                port = ''
                if host.startswith('[') and ']' in host:
                  closing = host.find(']')
                  host_inner = host[1:closing]
                  rem = host[closing+1:]
                  host = host_inner
                  if rem.startswith(':'):
                    port = rem[1:]
                elif ':' in hostport:
                  host, port = hostport.rsplit(':', 1)

                print(f"DBG: host={host or '<missing>'} port={port or '<missing>'} db={db or '<missing>'} user={user or '<missing>'}")
              except Exception as e:
                print('DBG: parse error -', str(e))
          PY

            cat > /tmp/apply_admin_api_migration.py <<'PY'
            #!/usr/bin/env python3
            import os, subprocess, sys, time
            from urllib.parse import unquote

            u = os.getenv('SUPABASE_DB_URL')
            if not u:
              print('ERROR: SUPABASE_DB_URL empty')
              sys.exit(2)

            # Robust parsing approach:
            # - split on '://' then take the rest
            # - split off the database name by rsplit('/', 1)
            # - split netloc on the last '@' (so passwords containing '@' are preserved)
            # - split host/port using rsplit(':', 1)
            rest = u.split('://', 1)[1] if '://' in u else u
            netloc_and_path = rest
            if '/' in rest:
              netloc, dbname = rest.rsplit('/', 1)
            else:
              netloc = rest
              dbname = ''

            if '@' in netloc:
              creds, hostport = netloc.rsplit('@', 1)
            else:
              creds = ''
              hostport = netloc

            # creds may be user[:password]
            if creds and ':' in creds:
              user, password = creds.split(':', 1)
            else:
              user = creds
              password = ''

            # hostport may be host[:port]
            if ':' in hostport:
              host, port = hostport.rsplit(':', 1)
              try:
                port = int(port)
              except Exception:
                port = 5432
            else:
              host = hostport
              port = 5432

            user = unquote(user or '')
            password = unquote(password or '')
            host = host or ''
            dbname = (dbname or '').lstrip('/') or ''

          if not (host and dbname and user):
              print('ERROR: Failed to parse host/user/db from SUPABASE_DB_URL')
              print('url=', u)
              sys.exit(2)

          sql = 'ALTER TABLE IF EXISTS public.site_settings ADD COLUMN IF NOT EXISTS admin_api_url text;'
          env = dict(os.environ)
          env['PGPASSWORD'] = password

          # Increase attempts and add verbose output to capture stdout/stderr for diagnostics
          max_attempts = 10
          for attempt in range(1, max_attempts + 1):
              print(f'Attempt {attempt}/{max_attempts} - trying direct connection via URI')
              # Try direct connection with the full connection URL first (psql accepts a URI argument)
              # Try direct connection via URI first (psql will handle credentials present in the URI)
              proc = subprocess.run(['psql', u, '-c', sql], env=env, capture_output=True, text=True)
              print('Direct attempt stdout:\n', proc.stdout)
              print('Direct attempt stderr:\n', proc.stderr)
              rc = proc.returncode
              if rc == 0:
                  print('Migration applied successfully (direct)')
                  sys.exit(0)

              print(f'direct psql attempt returned {rc} — trying explicit host/port (fallback)')
              # fallback: explicit host/port/user/db invocation
                # fallback: resolve host to IPv4 if necessary and use explicit host/port/user/db
                # prefer a numeric IPv4 address if available to avoid IPv6 routing issues on hosted runners
                try:
                  import socket
                  addrs = socket.getaddrinfo(host, None)
                  ipv4 = next((ai[4][0] for ai in addrs if ai[0] == socket.AF_INET), None)
                  if ipv4:
                    host_to_use = ipv4
                  else:
                    host_to_use = host
                except Exception:
                  host_to_use = host

                cmd = ['psql', '-h', host_to_use, '-p', str(port), '-U', user, '-d', dbname, '-c', sql]
              proc2 = subprocess.run(cmd, env=env, capture_output=True, text=True)
              print('Fallback stdout:\n', proc2.stdout)
              print('Fallback stderr:\n', proc2.stderr)
              rc2 = proc2.returncode
              if rc2 == 0:
                  print('Migration applied successfully (via fallback host/port)')
                  sys.exit(0)

              print(f'Both attempts failed (direct={rc}, fallback={rc2}); retrying after backoff')
              # Exponential backoff plus a small jitter
              delay = attempt * 3 + (attempt % 3)
              time.sleep(delay)

          print('All attempts failed — migration not applied')
          sys.exit(3)
          PY

          # strip common indentation introduced by YAML heredoc (ensure valid python file)
          # Use textwrap.dedent to remove the shared indent while preserving inner code indentation
          # remove the smallest leading indentation shared by all non-empty lines.
          # This left-aligns top-level code while preserving relative indentation for inner blocks.
          # Use the first non-empty line's indentation as the amount to remove
          python -c "import pathlib; p=pathlib.Path('/tmp/apply_admin_api_migration.py'); txt=p.read_text(); lines=txt.splitlines(); first=(next((l for l in lines if l.strip()), '') ); n = len(first)-len(first.lstrip(' ')) if first else 0; out='\n'.join([l[n:] if l.startswith(' ' * n) else l for l in lines])+'\n'; p.write_text(out)" || true

          # Print a preview of the generated file for debugging (safe: file contains no secrets)
          echo '--- Generated migration script (first 200 lines) ---'
          sed -n '1,200p' /tmp/apply_admin_api_migration.py || true

          python /tmp/apply_admin_api_migration.py > /tmp/apply_admin_api_migration.log 2>&1 || (
            echo 'Migration script returned non-zero; check /tmp/apply_admin_api_migration.log for details'
            echo '--- Last 200 lines of migration log ---'
            tail -n 200 /tmp/apply_admin_api_migration.log || true
            exit 1
          )

      - name: Upload migration logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: admin-api-migration-logs
          path: /tmp/apply_admin_api_migration.log
