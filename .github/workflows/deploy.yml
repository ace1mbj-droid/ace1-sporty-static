name: Build & FTP Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: CI guard â€” prevent accidental production deploys
        if: github.event_name != 'workflow_dispatch'
        run: |
          if [ "${{ secrets.ALLOW_PRODUCTION_DEPLOY }}" != "true" ]; then
            echo "Automatic production deploys are disabled. Re-run via 'workflow_dispatch' or set 'ALLOW_PRODUCTION_DEPLOY=true' temporarily."
            exit 1
          fi

      - name: Use Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Prepare dist folder
        run: |
          rm -rf dist || true
          rm -rf dist-public || true
          rm -rf dist-private || true
          mkdir -p dist
          mkdir -p dist-public
          mkdir -p dist-private
          # Copy only what we need for the static site; drop tooling/docs/tests/server content before FTP
          rsync -av \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='node_modules' \
            --exclude='.vscode' \
            --exclude='dist' \
            --exclude='tests' \
            --exclude='test-results' \
            --exclude='sql' \
            --exclude='supabase' \
            --exclude='server' \
            --exclude='package' \
            --exclude='docs' \
            --exclude='reproduction' \
            --exclude='scripts' \
            --exclude='**/*.md' \
            --exclude='**/*.txt' \
            ./ dist-public/ || true

          # Prepare non-public artifacts (kept outside web-accessible root on FTP)
          for d in docs sql supabase server scripts package reproduction; do
            if [ -d "$d" ]; then
              rsync -av "$d" dist-private/ || true
            fi
          done

          # Generate manifests for visibility
          find dist-public -type f | sort > public-files.txt || true
          find dist-private -type f | sort > private-files.txt || true

      - name: Validate public files allowlist
        run: |
          set -e
          echo "Validating file types in dist-public against allowlist"
          DISALLOWED=$(find dist-public -type f \
            ! -name '*.html' \
            ! -name '*.css' \
            ! -name '*.js' \
            ! -name '*.png' \
            ! -name '*.jpg' \
            ! -name '*.jpeg' \
            ! -name '*.webp' \
            ! -name '*.gif' \
            ! -name '*.svg' \
            ! -name '*.ico' \
            ! -name '*.woff' \
            ! -name '*.woff2' \
            ! -name '*.ttf' \
            ! -name '*.eot' -print)
          if [ -n "$DISALLOWED" ]; then
            echo "Found disallowed files in dist-public:"
            echo "$DISALLOWED"
            exit 1
          fi
          echo "Allowlist validation passed."

      - name: Inject ADMIN_API_URL into built admin.html (optional)
        # Run only when either admin API secret is provided
        env:
          ADMIN_API_URL: ${{ secrets.ADMIN_API_URL }}
          SUPABASE_FUNCTIONS_URL: ${{ secrets.SUPABASE_FUNCTIONS_URL }}
        if: ${{ env.ADMIN_API_URL != '' || env.SUPABASE_FUNCTIONS_URL != '' }}
        run: |
          # prefer ADMIN_API_URL secret (explicit); fall back to SUPABASE_FUNCTIONS_URL + /admin-reset
          if [ -n "$ADMIN_API_URL" ]; then
            ADMIN_URL="$ADMIN_API_URL"
          else
            ADMIN_URL="${SUPABASE_FUNCTIONS_URL}/admin-reset"
          fi

          if [ -f dist-public/admin.html ]; then
            echo "Injecting ADMIN_API_URL=${ADMIN_URL} into dist/admin.html"
            sed -i "s#__ADMIN_API_URL__#${ADMIN_URL}#g" dist-public/admin.html
          else
            echo "dist/admin.html not found; skipping injection"
          fi

      - name: FTP Health Check (FTPS)
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USER }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
          FTP_PORT: ${{ secrets.FTP_PORT }}
          FTP_SSL_VERIFY: ${{ secrets.FTP_SSL_VERIFY }}
        run: |
          sudo apt-get update && sudo apt-get install -y lftp
          set -e
          PORT=${FTP_PORT:-21}
          VERIFY=${FTP_SSL_VERIFY:-true}
          echo "Running FTP health check against ${FTP_HOST}:${PORT}"
          lftp -p "$PORT" -e "set net:max-retries 1; set net:timeout 20; set ftp:ssl-force true; set ftp:ssl-protect-data true; set ssl:verify-certificate $VERIFY; set cmd:fail-exit true; open -u $FTP_USER,$FTP_PASSWORD $FTP_HOST; pwd; ls; bye" | tee ftp-healthcheck.log
          echo "FTP health check complete."

      - name: Upload healthcheck & manifests
        uses: actions/upload-artifact@v4
        with:
          name: ftp-scan-report
          path: |
            ftp-healthcheck.log
            public-files.txt
            private-files.txt

      - name: Generate checksums for public files
        run: |
          set -e
          find dist-public -type f -exec sha256sum {} \; | sort > dist-public-checksums.sha256
          cp dist-public-checksums.sha256 dist-private/checksums-public.sha256 || true
        shell: bash

      - name: Set FTP target directories
        run: |
          if [ -n "${{ secrets.FTP_PUBLIC_DIR }}" ]; then echo "PUBLIC_DIR=${{ secrets.FTP_PUBLIC_DIR }}" >> $GITHUB_ENV; else echo "PUBLIC_DIR=/public_html" >> $GITHUB_ENV; fi
          if [ -n "${{ secrets.FTP_PRIVATE_DIR }}" ]; then echo "PRIVATE_DIR=${{ secrets.FTP_PRIVATE_DIR }}" >> $GITHUB_ENV; else echo "PRIVATE_DIR=/private" >> $GITHUB_ENV; fi

      - name: FTP Deploy (public)
        uses: SamKirkland/FTP-Deploy-Action@v4.3.5
        with:
          server: ${{ secrets.FTP_HOST }}
          username: ${{ secrets.FTP_USER }}
          password: ${{ secrets.FTP_PASSWORD }}
          local-dir: ./dist-public/
          server-dir: ${{ env.PUBLIC_DIR }}
          protocol: ftps
          port: 21
          dangerous-clean-slate: false
          state-name: ace1-public-deploy-state.json
          exclude: |
            **/.git*
            **/.github/**
            **/node_modules/**
            dist/**
            **/*.map
            **/*.ts

      - name: FTP Deploy (private)
        if: ${{ hashFiles('dist-private/**') != '' }}
        uses: SamKirkland/FTP-Deploy-Action@v4.3.5
        with:
          server: ${{ secrets.FTP_HOST }}
          username: ${{ secrets.FTP_USER }}
          password: ${{ secrets.FTP_PASSWORD }}
          local-dir: ./dist-private/
          server-dir: ${{ env.PRIVATE_DIR }}
          protocol: ftps
          port: 21
          dangerous-clean-slate: false
          state-name: ace1-private-deploy-state.json
          exclude: |
            **/.git*
            **/.github/**
            **/node_modules/**
            dist/**
            **/*.map
            **/*.ts

# Secrets to set: FTP_HOST, FTP_USER, FTP_PASSWORD
# Optional secrets: FTP_PUBLIC_DIR (default '/public_html'), FTP_PRIVATE_DIR (default '/private'), FTP_PORT (default 21)
# Optional hardening: ALLOW_PRODUCTION_DEPLOY (require manual approval), FTP_SSL_VERIFY (default 'true')
# Alternative: use SSH key or other deployment action if host requires it.
